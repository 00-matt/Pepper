// -*- mode: c++; -*-

#include <cstddef>

namespace std {

template <class T, std::size_t N>
struct array {
    using value_type = T;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using reference = T&;
    using const_reference = const T&;
    using pointer = T*;
    using const_pointer = const T*;

    alignas(value_type) value_type m_data[N];

    constexpr reference operator[](size_type pos) { return m_data[pos]; }
    constexpr const_reference operator[](size_type pos) const { return m_data[pos]; }
    constexpr reference front() { return m_data[0]; }
    constexpr const_reference front() const { return m_data[0]; }
    constexpr reference back() { return m_data[N - 1]; }
    constexpr const_reference back() const { return m_data[N - 1]; }
    constexpr pointer data() noexcept { return m_data; }
    constexpr const_pointer data() const noexcept { return m_data; }

    [[nodiscard]] constexpr bool empty() const noexcept { return N == 0; }
    constexpr size_type size() const noexcept { return N; }
    constexpr size_type max_size() const noexcept { return N; }

    constexpr void fill(const_reference value) {
        for (size_type i = 0; i < N; i++) m_data[i] = value;
    }
};

} // namespace std
